# 常见问题（FAQ）

[English](FAQ.md) | [中文](FAQ.zh-CN.md)

关于币安傅里叶回测器的常见问题和答案。

## 目录

1. [常规问题](#常规问题)
2. [数据与缓存](#数据与缓存)
3. [傅里叶分析](#傅里叶分析)
4. [回测](#回测)
5. [优化](#优化)
6. [投资组合管理](#投资组合管理)
7. [性能与故障排查](#性能与故障排查)

---

## 常规问题

### 这个平台是做什么用的？

币安傅里叶回测器专为量化交易者和研究人员设计，用于：
- 使用高级信号处理技术分析加密货币价格数据
- 开发和回测趋势跟踪交易策略
- 使用多种算法优化策略参数
- 使用风险控制管理多币种投资组合

### 我需要编程经验才能使用吗？

**基本使用**：不需要。Streamlit UI 提供点击界面用于：
- 加载数据
- 运行回测
- 查看结果
- 导出交易日志

**高级使用**：需要。用于：
- 自定义策略开发
- API 级别集成
- 扩展代码库
- 自动化执行

### 这是否适合生产环境进行实盘交易？

**简短回答**：不适合，这是一个研究和回测平台。

**详细回答**：虽然回测引擎稳健且真实，但实盘交易需要：
- 实时订单执行基础设施
- 风险管理系统
- 监控和警报
- 监管合规
- 资金风险

将此平台用于策略开发和验证，然后单独实施生产系统。

### 支持哪些交易所？

目前：**仅币安**（通过 REST API 的现货市场）。

**计划未来支持**：
- 币安期货
- 其他主要交易所（Coinbase、Kraken 等）
- DeFi 协议（通过 The Graph 的 Uniswap）

### 我可以交易哪些加密货币？

任何币安现货交易对。默认支持：
- BTCUSDT
- ETHUSDT
- BNBUSDT
- ADAUSDT

**添加更多**：编辑 `core/data/loader.py` 中的 `SUPPORTED_SYMBOLS`。

---

## 数据与缓存

### 历史数据可以追溯到多久以前？

**币安可用性**：
- 比特币（BTC）：回到 2017 年
- 大多数主要山寨币：2018-2020 年
- 新上市币种：从上市日期开始

**平台限制**：无，仅受币安 API 限制。

### 缓存使用多少磁盘空间？

**估计**（Parquet 压缩）：
| 时间间隔 | 持续时间 | 大约大小 |
|----------|----------|------------|
| 30m | 1 年 | 约 5 MB |
| 1h | 1 年 | 约 2.5 MB |
| 4h | 1 年 | 约 0.6 MB |

**示例**：5 个币种，1h 数据，2 年 = 总共约 25 MB。

**存储**：由于 Parquet 列式压缩，非常高效。

### 我需要手动更新缓存的数据吗？

**不需要**。缓存系统自动：
1. 检测您有旧数据
2. 仅获取自上次更新以来的新柱
3. 附加到缓存
4. 处理缺口和去重

**手动刷新**：仅在怀疑损坏时使用"强制刷新"。

### 如果我的缓存数据损坏了怎么办？

**症状**：
- 加载缓存文件错误
- 图表中缺少数据
- 时间戳不一致

**解决方案**：
```bash
# 删除损坏的文件
rm data/cache/BTCUSDT_1h.parquet

# 或删除所有缓存
rm -rf data/cache/*

# 选中强制刷新重新加载
```

### 我可以使用来自其他来源的数据（CSV、数据库）吗？

**不能直接使用**，但您可以：

1. 将数据加载到 pandas DataFrame，包含必需的列：
   ```python
   # 必需列：open_time, open, high, low, close, volume
   df = pd.read_csv("my_data.csv")
   ```

2. 将时间戳转换为 pandas datetime：
   ```python
   df['open_time'] = pd.to_datetime(df['timestamp'])
   ```

3. 直接传递给回测引擎（绕过加载器）。

**注意**：目前无 UI 支持，需要 Python 脚本。

---

## 傅里叶分析

### 为什么使用傅里叶变换进行交易？

**传统平滑**（移动平均）：
- 滞后：总是滞后价格（周期/2）
- 固定窗口：不适应市场状态
- 端点：边界处行为差

**傅里叶平滑**：
- 基于频率：去除噪音同时保留趋势
- 自适应：自动处理不同的周期长度
- 端点：镜像填充避免边缘失真

**结果**：更清晰的趋势信号，滞后更少，假突破更少。

### 在上下文中"30m聚合"是什么意思？

**上下文**：中文术语意为"30 分钟聚合"。

**问题**：如何处理边界处的 30 分钟柱？
- OHLCV 数据必须对齐到 :00 或 :30 时间戳
- 边缘的部分柱被丢弃或填充

**平台中的解决方案**：
- 数据加载器强制时间戳对齐
- 查询边界处的部分柱被排除
- 确保 FFT 的一致柱间距

### 为什么选择 DCT 而非 FFT？

**FFT（快速傅里叶变换）**：
- 假设信号是周期性的
- 在边界处创建不连续性（重复信号）
- 复数值输出

**DCT（离散余弦变换）**：
- 假设信号在边界处反射（镜像）
- 更平滑的过渡，无不连续性
- 实值输出（更容易解释）

**对于金融数据**：DCT 更好，因为价格不是周期性的。

**可视化**：
```
FFT 边界：  ...x[n-1], x[n], x[0], x[1]...  （跳跃！）
DCT 边界：  ...x[n-1], x[n], x[n], x[n-1]... （平滑）
```

### FFT 频谱中的"主导峰值"是什么？

**定义**：频谱中功率最高的频率。

**解释**：价格数据中的主要周期。

**示例**：
- 24 柱处的峰值：日周期（1h 数据上的 24h）
- 168 柱处的峰值：周周期
- 12 柱处的峰值：半日周期

**用例**：
- 识别市场节奏
- 在主导周期附近设置 `min_trend_hours`
- 理解状态（趋势 vs. 周期性）

### 频谱热图如何帮助？

**显示什么**：时频表示。
- X 轴：时间（数据集进展）
- Y 轴：周期（柱数中的周期长度）
- 颜色：功率（红色 = 强周期，蓝色 = 弱周期）

**你可以看到什么**：
- 状态变化：从短周期到长周期的转变（反之亦然）
- 周期一致性：垂直带 = 稳定周期
- 周期不稳定性：分散的颜色 = 无主导周期

**交易洞察**：
- 强垂直带：可预测的市场，趋势跟踪有效
- 分散模式：不可预测，考虑均值回归或保持观望

### 周期和频率之间的关系是什么？

**数学**：
```
频率 = 1 / 周期
周期 = 1 / 频率
```

**示例**（1h 时间间隔）：
- 周期 = 24 柱 → 频率 = 1/24 ≈ 0.042 周期/柱
- 周期 = 168 柱 → 频率 = 1/168 ≈ 0.006 周期/柱

**截止频率**：
- 截止频率 = 1 / min_period_bars
- 保留长于 `min_period` 的周期
- 去除短于 `min_period` 的周期

---

## 回测

### 回测结果真实吗？

**是的，但有假设**：

**包括的真实因素**：
- ✅ 下一柱成交（无前视偏差）
- ✅ 手续费（可配置）
- ✅ 滑点（可配置）
- ✅ 止损/止盈柱内检查
- ✅ 仓位规模限制

**不包括的因素**：
- ❌ 市场影响（大订单移动价格）
- ❌ 订单簿深度
- ❌ 部分成交
- ❌ 延迟/连接问题

**建议**：
- 在回测中使用保守的手续费和滑点
- 实盘交易时从小仓位开始
- 预期绩效会比回测差 10-20%

### 为什么我的回测显示零交易？

**常见原因**：

1. **斜率阈值太高**：
   - 趋势从未足够陡峭进入
   - 解决方案：降低 `slope_threshold` 或设置为 0.0

2. **止损太紧**：
   - 在信号之前立即触及
   - 解决方案：增加 `k_stop`（例如，从 1.5 到 2.5）

3. **数据太短**：
   - 不足以平滑或生成信号
   - 解决方案：增加日期范围

4. **MTF 过滤器太严格**：
   - 时间框架从不对齐
   - 解决方案：禁用 MTF 或使用较少时间框架

**调试**：
- 检查图表上的平滑线
- 验证生成了信号标记
- 在没有 MTF 的情况下测试
- 降低过滤器严格性

### 我应该使用多少数据进行回测？

**建议**：

| 目的 | 持续时间 | 原因 |
|---------|----------|--------|
| **快速测试** | 3-6 个月 | 快速迭代，验证策略逻辑 |
| **稳健验证** | 1-2 年 | 包含多个市场状态 |
| **步进式** | 2-3 年 | 足够的样本外测试周期 |

**考虑因素**：
- **更多数据**：更稳健但计算更慢
- **更少数据**：快速但可能过拟合
- **包含**：牛市、熊市和横盘市场

### 什么是"前视偏差"，如何避免？

**定义**：在信号生成时使用未来数据。

**示例偏差**：
```python
# 错误：在柱 t 使用柱 t 的收盘价进入
if close[t] > smoothed[t]:
    enter_at_price = close[t]  # 这是前视！

# 正确：在柱 t+1 进入
if close[t] > smoothed[t]:
    enter_at_price = open[t+1]  # 下一柱开盘
```

**平台如何避免**：
- 信号在柱收盘时生成
- 成交在下一柱开盘时
- 止损检查使用下一柱的高/低

### 如何解释绩效指标？

**关键指标**：

**夏普比率**：
- < 0：亏损策略
- 0-1：差到可接受
- 1-2：良好
- \> 2：优秀
- **目标**：至少 1.0 用于生产

**索提诺比率**：
- 类似夏普但仅惩罚下行
- 对于不对称策略更好
- **目标**：> 1.5

**最大回撤**：
- 最大峰谷跌幅
- **可接受**：< 20%
- **良好**：< 10%
- **风险**：> 30%（高风险）

**胜率**：
- 盈利交易的百分比
- **不要孤立地优化**（可能导致小赢大亏）
- **典型**：40-60% 用于趋势跟踪

**盈利因子**：
- 总盈利 / 总亏损
- < 1.0：亏损
- 1.0-1.5：边际
- 1.5-2.0：良好
- \> 2.0：强劲

### 边界处理如何工作？

**问题**：平滑和 FFT 需要完整窗口，但数据集有限。

**解决方案**：

1. **镜像填充**（用于 DCT 平滑）：
   ```
   原始：     [x₀, x₁, x₂, ..., xₙ]
   填充：[xₙ, ..., x₁, x₀, x₁, ..., xₙ, xₙ₋₁, ..., x₁]
   ```
   创建平滑边界扩展

2. **窗口截断**（用于 Welch PSD）：
   - 前几个窗口：不完整，跳过
   - 中间窗口：完整，使用
   - 后几个窗口：不完整，跳过

3. **信号生成**：
   - 在平滑有效后开始
   - 在数据结束前停止
   - 结果：略少于数据长度的交易

---

## 优化

### 哪种优化方法最好？

**取决于目标**：

**网格搜索**：
- ✅ 详尽，找到最佳网格点
- ✅ 确定性，可重现
- ❌ 慢，组合呈指数增长
- **何时使用**：2-3 个参数，小范围

**随机搜索**：
- ✅ 快速，可扩展
- ✅ 探索网格点之间
- ❌ 可能错过最佳点
- **何时使用**：大参数空间，有限时间

**贝叶斯优化**：
- ✅ 高效，智能搜索
- ✅ 平衡探索与利用
- ❌ 顺序，较少并行化
- **何时使用**：昂贵的评估，寻找全局最优

**建议**：从随机开始（快速概览），然后使用贝叶斯（细化）。

### 如何避免过拟合？

**技术**：

1. **样本外测试**：
   - 在一部分数据上优化
   - 在另一部分上验证
   - 步进式分析自动化此操作

2. **简单性偏好**：
   - 更少的参数 = 更少的过拟合
   - 避免 > 5-6 个自由参数

3. **正则化目标**：
   - 优化夏普比率（不是总收益）
   - 惩罚复杂性（交易次数）
   - 要求最小交易次数（例如，> 30）

4. **蒙特卡洛验证**：
   - 重采样交易
   - 检查指标稳定性
   - 如果大方差则丢弃

5. **多市场测试**：
   - 在 BTC 上优化
   - 在 ETH、BNB 上验证
   - 如果不通用则不稳健

### 步进式分析如何工作？

**概念**：模拟实时优化。

**过程**：
```
数据：[=======训练=======][==测试==] 拆分 1
      [=========训练=========][==测试==] 拆分 2
      [===========训练===========][==测试==] 拆分 3
```

**步骤**：
1. 在拆分 1 训练上优化
2. 在拆分 1 测试上应用最佳参数
3. 记录样本外绩效
4. 重复拆分 2、3...
5. 汇总样本外结果

**类型**：
- **锚定**：训练集增长（上图）
- **滚动**：训练集大小固定

**优势**：
- 真正的样本外测试
- 检测过拟合（样本内好 vs. 样本外差）
- 模拟生产使用

### 我应该优化哪些参数？

**推荐优化**：

1. **趋势周期**（`min_trend_hours`）：
   - 范围：12-72 小时
   - 影响：信号频率和质量

2. **截止缩放**（`cutoff_scale`）：
   - 范围：0.5-2.0
   - 影响：平滑激进程度

3. **止损乘数**（`k_stop`，`k_profit`）：
   - 范围：k_stop 1.5-3.0，k_profit 2.0-5.0
   - 影响：风险/收益比

4. **ATR 周期**（`atr_period`）：
   - 范围：10-20
   - 影响：止损适应性

**避免优化**：
- 手续费/滑点（使用真实值）
- 初始资金（不影响 %）
- 日期范围（使用所有可用数据）

**危险**：
- 优化 > 6 个参数（过拟合风险）
- 优化到小数点后多位（虚假精度）

---

## 投资组合管理

### 我应该使用什么加权方法？

**比较**：

| 方法 | 优势 | 劣势 | 何时使用 |
|--------|------|------|----------|
| **等权** | 简单，多样化 | 忽略风险 | 类似风险资产 |
| **波动率** | 标准化风险 | 倾向低波动率 | 混合波动率 |
| **风险平价** | 真正平衡 | 计算成本高 | 最优多样化 |
| **市值** | 市场基准 | 集中在大型资产 | 跟踪市场 |

**建议**：
- **开始**：等权（简单）
- **生产**：波动率或风险平价（风险管理）
- **基准**：市值（与市场比较）

### 多少币种最优？

**权衡**：

| 币种数 | 多样化 | 计算 | 跟踪 | 推荐 |
|--------|-------------|------------|----------|---------------|
| 2-3 | 低 | 快 | 容易 | 测试 |
| 5-10 | 良好 | 中等 | 可管理 | **推荐** |
| 10-20 | 高 | 慢 | 困难 | 高级 |
| 20+ | 边际 | 非常慢 | 复杂 | 过度 |

**经验法则**：5-10 个币种的投资组合在多样化和实用性之间平衡良好。

**选择标准**：
- 流动性：> $100M 日成交量
- 历史：> 1 年数据
- 低相关性：< 0.7 相互
- 质量：前 50 名市值

### 我应该多久再平衡一次？

**频率影响**：

| 频率 | 跟踪 | 手续费 | 用例 |
|-----------|---------|------|---------|
| **每日** | 严格 | 高 | 指数跟踪 |
| **每周** | 良好 | 中等 | **推荐** |
| **每月** | 宽松 | 低 | 长期 |
| **阈值** | 变化 | 最低 | 高效 |

**建议**：
- **活跃**：每周或 5% 阈值
- **被动**：每月或 10% 阈值
- **长期**：每季度或 15% 阈值

**阈值再平衡**：
```python
如果任何权重偏离目标 > 阈值：
    再平衡
否则：
    跳过（节省手续费）
```

### 如何解释相关性矩阵？

**阅读矩阵**：
```
        BTC   ETH   BNB
BTC    1.00  0.85  0.75
ETH    0.85  1.00  0.80
BNB    0.75  0.80  1.00
```

**解释**：
- **1.0**：完全正相关（对角线）
- **0.8-1.0**：强相关（同向移动）
- **0.5-0.8**：中等相关
- **0.0-0.5**：弱相关（良好的多样化）
- **< 0.0**：负相关（优秀的对冲）

**加密货币中的典型**：
- BTC-ETH：0.7-0.9（高）
- BTC-稳定币：0.0-0.2（低，良好）
- 主要山寨币：0.6-0.8（中等到高）

**见解**：
- 高相关性：有限的多样化益处
- 低相关性：良好的投资组合弹性
- 负相关性：有效对冲（加密货币中罕见）

---

## 性能与故障排查

### 为什么数据加载缓慢？

**原因**：

1. **首次获取**：
   - 从币安 API 下载历史数据
   - **正常**：几分钟用于年数据
   - **解决方案**：要有耐心，未来加载将很快

2. **速率限制**：
   - 触及币安 1200 请求/分钟限制
   - **解决方案**：减少日期范围，等待重试

3. **网络问题**：
   - 慢连接或间歇性故障
   - **解决方案**：检查互联网，尝试较小的范围

4. **缓存损坏**：
   - 系统重复尝试加载坏文件
   - **解决方案**：删除缓存，强制刷新

**预期性能**：
- **首次**：30-180 秒用于 1 年数据
- **缓存**：< 1 秒用于任何范围

### 为什么回测需要很长时间？

**原因**：

1. **大数据集**：
   - 30m 数据，多年：数百万点
   - **解决方案**：使用更高时间框架（1h、4h）

2. **频谱分析**：
   - Welch PSD 计算密集
   - **解决方案**：增加 `window_length`，减少重叠

3. **优化**：
   - 数百次回测迭代
   - **正常**：预期缓慢
   - **解决方案**：使用随机而非网格，减少迭代

**基准**（1 年 1h 数据）：
- **单次回测**：1-3 秒
- **网格搜索（100 组合）**：2-5 分钟
- **贝叶斯（50 次迭代）**：3-8 分钟

### 如何加快优化速度？

**技术**：

1. **使用随机搜索**：
   - 比网格快 10-100 倍
   - 对于大空间仍然有效

2. **减少参数空间**：
   - 更少参数 = 指数级更快
   - 关注高影响参数

3. **使用更短数据**：
   - 在 6 个月上优化
   - 在完整数据集上验证

4. **并行化**（高级）：
   ```python
   # 在 config 中启用
   n_jobs = -1  # 使用所有核心
   ```

5. **缓存中间结果**：
   - 系统自动缓存平滑线
   - 跨参数组合重用

### 我遇到内存错误怎么办？

**症状**：
```
MemoryError: Unable to allocate array
```

**解决方案**：

1. **减少数据范围**：
   - 从多年到几个月
   - 临时缩减以完成

2. **使用更高时间框架**：
   - 4h 而非 30m（数据点减少 8 倍）
   - 仍然捕获趋势

3. **减少频谱窗口**：
   - `window_length = 128` 而非 512
   - 较少内存用于 PSD

4. **批量优化**：
   - 将网格分成块
   - 单独运行每个块

5. **增加交换**（Linux）：
   ```bash
   sudo fallocate -l 8G /swapfile
   sudo mkswap /swapfile
   sudo swapon /swapfile
   ```

**内存估计**：
- 1 年 1h 数据：约 50 MB
- 优化（1000 组合）：500 MB-2 GB
- 投资组合（10 个币种）：200 MB-1 GB

### UI 未加载或冻结怎么办？

**常见问题**：

1. **端口冲突**：
   ```bash
   # 终止现有 Streamlit
   pkill -f streamlit
   
   # 或使用不同端口
   streamlit run app/ui/main.py --server.port 8502
   ```

2. **浏览器缓存**：
   - 硬刷新（Ctrl+Shift+R）
   - 清除浏览器缓存
   - 尝试隐身模式

3. **Streamlit 挂起**：
   - 检查终端输出是否有错误
   - Ctrl+C 并重启
   - 检查日志中的异常

4. **数据集太大**：
   - UI 尝试渲染数百万点
   - 减少日期范围
   - 使用更高时间框架

5. **会话状态损坏**：
   ```bash
   rm data/presets/last_state.yaml
   ```

### 如何启用调试日志？

**方法 1：环境变量**
```bash
export LOG_LEVEL=DEBUG
streamlit run app/ui/main.py
```

**方法 2：代码中**
```python
# 在 config/settings.py 中
import logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
```

**日志级别**：
- `DEBUG`：详细，所有操作
- `INFO`：一般进度
- `WARNING`：潜在问题
- `ERROR`：故障

**查看日志**：
- 终端输出（Streamlit 运行时）
- 重定向到文件：
  ```bash
  streamlit run app/ui/main.py > app.log 2>&1
  ```

---

## 多时间框架对齐

### 不同时间框架如何对齐？

**问题**：30m、1h 和 4h 柱不自然对齐。

**解决方案**：

1. **时间戳对齐**：
   - 所有时间框架对齐到 UTC 午夜
   - 30m：:00 和 :30
   - 1h：:00
   - 4h：00:00、04:00、08:00、12:00、16:00、20:00

2. **前向填充**：
   ```python
   # 1h 趋势用于 30m 执行
   30m 00:00 → 使用 1h 00:00 趋势
   30m 00:30 → 使用 1h 00:00 趋势（前向填充）
   ```

3. **滞后考虑**：
   - 更高时间框架滞后更多
   - 4h 趋势在 4 小时末更新
   - 30m 可能在旧 4h 趋势上交易

**实现**（`core/analysis/mtf.py`）：
- 自动时间戳合并
- 前向填充缺失值
- 验证对齐

---

## 其他

### 我可以将此用于非加密资产吗？

**是的**，带修改：

1. **数据适配器**：
   - 实现自定义数据加载器
   - 转换为所需格式（OHLCV）
   - 保持时间戳对齐

2. **考虑因素**：
   - **股票**：市场时间，周末缺口
   - **外汇**：24/5 交易
   - **商品**：合约展期

3. **修改**：
   - 调整手续费/滑点
   - 处理市场关闭
   - 账户展期成本

**社区贡献**欢迎用于其他资产类！

### 策略可以自动化吗？

**当前**：否。这是一个回测平台。

**未来计划**：
- 纸交易模式（模拟实盘）
- 币安 API 集成（实盘执行）
- Webhook 通知
- 风险管理覆盖

**现在**：
- 在此处开发策略
- 在单独系统中实施执行
- 使用回测参数

### 如何贡献代码？

**欢迎**！查看 README.md 中的贡献指南。

**领域**：
- 新策略类型（均值回归、套利）
- 其他交易所（Coinbase、Kraken）
- UI 改进
- 性能优化
- 文档和示例

**过程**：
1. Fork 仓库
2. 创建功能分支
3. 添加测试
4. 提交 Pull Request

### 支持和帮助在哪里？

**资源**：
- **文档**：`docs/` 文件夹
- **示例**：`examples/` 文件夹
- **问题**：GitHub Issues
- **讨论**：GitHub Discussions

**在提问之前**：
1. 检查此 FAQ
2. 阅读相关文档
3. 搜索现有 issues
4. 包含：错误消息、配置、步骤重现

---

**未找到答案？**在 GitHub Discussions 中提问！
